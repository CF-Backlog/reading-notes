### What is refactoring?

> Refactoring is a systematic process of improving code
without creating new functionality that can transform
a mess into clean code and simple design.

### What is clean code anyway?

> Clean code is code that is easy to read, understand and maintain. Clean code makes software development predictable
and increases the quality of a resulting product.

### How do we refactor our code, how does it all work? 

> Performing refactoring step-by-step and running tests after each change are key elements of refactoring that make it predictable and safe. Composing Methods: Much of refactoring is devoted to correctly composing methods but also making sure that they are streamlined. Moving Features between Objects: This involves functionality between classes, creating new classes, and hiding implementation details from public access. Organizing Data: This involves data handling, replacing primitives with rich class functionality,  and untangling of class associations, which makes classes more portable and reusable. Simplifying Conditional Expressions: Conditionals tend to get more and more complicated in their logic over time. This involves taking multiple conditionals that lead to the same result or action and consolidating all of them into ONE single expression. Simplify Method Calls: Here we can rename methods, add or remove parameters, separate queries from modifiers and preserve whole Objects. Deal with Generalization: For example, this could involve replacing delegation with inheritance and forming template methods.

### What is functional programming?

> Functional programming or FP, is the process of building software by composing pure functions, avoiding shared state, mutable data, and side-effects.  Functional programming is declarative rather than imperative, and application state flows through pure functions. Contrast with object oriented programming, where application state is usually shared and colocated with methods in objects. Functional code tends to be more concise, more predictable, and easier to test than imperative or object oriented code.

